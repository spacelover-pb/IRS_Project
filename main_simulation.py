# -*- coding: utf-8 -*-
"""Untitled9.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vSG4wQFThW1UrP2JA75I7KYtaKXnol8w
"""

import numpy as np
import matplotlib.pyplot as plt

#  simulation parameters
Pt = 1

#Compute the noise power in dBm
sigma2dBm = -80
sigma2 = 10**(sigma2dBm/10)

#Gamma in dB
GammadB = 9 
Gamma = 10**(sigma2dBm/20)


#Carrier frequency (in GHz)
fc = 3
#Distance between the transmitter and IRS
d_SR = 50
#Minimum distance between receiver and IRS 
dv = 2

AP_Xcoordinate = 0
AP_Ycoordinate = 0
AP_Zcoordinate = 0

IRS_Xcoordinate = 0
IRS_Ycoordinate = d_SR
IRS_Zcoordinate = 0


#Define the range of d1 values in the simulation setup
distances = np.linspace(0, 65, 100)

#Number of antenna at AP 
N = 1

#Set the amplitude reflection coefficient
beta = 1

#Number of sub surfaces
M = 12

#design of phase vector of IRS
psi = np.linspace(1,2*np.pi,M)
phi = beta * np.exp(1j*psi)
Phi = np.diag(phi)

pathloss_3GPP_NLOS = lambda x,y: 10**((30 - 10*y*np.log10(x))/10)


Gaussian_dist = np.sqrt(0.5) *(np.random.randn(10**5,1) + 1j*np.random.randn(10**5,1)) 
#Small scale fading channel
# gSDLOS = np.sqrt(0.5) *(np.random.randn(N,1) + 1j*np.random.randn(N,1)) 
# gSRLOS = np.sqrt(0.5) *(np.random.randn(N,M) + 1j*np.random.randn(N,M)) 
# gRDLOS = np.sqrt(0.5) *(np.random.randn(1, M) + 1j*np.random.randn(1, M)) 
gSDLOS = np.reshape(Gaussian_dist[0:N,0], (N, 1))
gSRLOS = np.reshape(Gaussian_dist[100:100+M*N,0], (N, M))
gRDLOS = np.reshape(Gaussian_dist[1000:1000+M,0], (1, M))


# Simulation of user-AP distances
#distances = np.array([15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65])


# Calculate achievable rate C(phi) for each distance
C_phi = np.zeros((len(distances)))


for d in range(0, len(distances)):
    
    #Extract value of d1
    d1 = distances[d]
       
    #Compute distance between the transmitter and User
    d_SD = np.sqrt(d1**2 + dv**2)
        
    #Compute distance between the IRS and User
    d_RD = np.sqrt((d1-d_SR)**2 + dv**2)
    
    #Compute the channel gains using the 3GPP models and antenna gains (dB)
    betaSR = pathloss_3GPP_NLOS(d_SR, 2.2) 
    betaRD = pathloss_3GPP_NLOS(d_RD, 2.4) 
    betaSD = pathloss_3GPP_NLOS(d_SD, 3.5) 
    
    
    
    #Channel response in time domain
    gSR = np.sqrt(betaSR) * gSRLOS
    gRD = np.sqrt(betaRD) * gRDLOS
    gSD = np.sqrt(betaSD) * gSDLOS
    
    # Calculate  W_n(phi) for each subcarrier
    W = np.power(np.abs(gSR @ Phi @ gRD.T + gSD), 2)
    
    
    
    rate = np.log2(1+(Pt*W/(Gamma*sigma2)))
    C_phi[d] = rate[0,0]

# MSE Calculation
Pt_dBm = np.arange(0, 41, 5)
Pt_linear = 10 ** ((Pt_dBm - 30) / 10)
No_of_carriers = 64
Np = 8
L = 6
mse = np.zeros((len(Pt_linear)))
for pt in range(0, len(Pt_linear)):
    mse[pt] = (sigma2 * No_of_carriers * L / (Np * Pt_linear[pt])) * np.trace(np.linalg.inv(Phi.T.conj() @ Phi))
    
    
    
plt.figure(figsize=(10, 6))
plt.plot(distances, C_phi, 'bo-', label="Achievable Rate (Simulated)", markersize=6)
plt.xlabel("User-AP Horizontal Distance (m)")
plt.ylabel("Achievable Rate (bps/Hz)")
plt.title("Achievable Rate vs. User-AP Horizontal Distance")
plt.grid(True)
plt.legend(loc="upper left")
plt.tight_layout()
plt.show()


# Plot MSE vs Transmit Power
plt.figure(figsize=(8, 6))
plt.semilogy(Pt_dBm, mse, 'o-', label='Proposed CE (Sim)')
plt.xlabel('Total Transmission Power $P_t$ (dBm)')
plt.ylabel('Normalized MSE')
plt.title('MSE vs Transmit Power')
plt.grid(True, which='both')
plt.legend()


plt.figure(figsize=(10, 6))
plt.scatter(AP_Xcoordinate, AP_Ycoordinate, marker='o', label='AP')
plt.scatter(IRS_Xcoordinate, IRS_Ycoordinate, marker='*', label='IRS')
plt.scatter(distances, dv*np.ones(len(distances)), marker='o', label='UE')
plt.xlabel("User-AP Horizontal Distance (m)")
plt.ylabel("Achievable Rate (bps/Hz)")
plt.title("Achievable Rate vs. User-AP Horizontal Distance")
plt.grid(True)
plt.legend(loc="upper right")